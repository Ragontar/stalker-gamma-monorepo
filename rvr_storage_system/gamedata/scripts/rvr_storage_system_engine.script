AddScriptCallback("on_actor_inventory_update_finished")
AddScriptCallback("on_storage_inventory_update_finished")

function on_game_start()
    RegisterScriptCallback("actor_on_first_update", init)
    RegisterScriptCallback("on_key_press", on_key_press)
    RegisterScriptCallback("save_state", save_state)
    RegisterScriptCallback("load_state", load_state)
    RegisterScriptCallback("actor_item_to_ruck", actor_item_to_ruck)
    RegisterScriptCallback("on_actor_inventory_update_finished", on_actor_inventory_update_finished)
    RegisterScriptCallback("on_storage_inventory_update_finished", on_storage_inventory_update_finished)
end

local weight_unit = game.translate_string("st_kg")
local snd_open = sound_object([[interface\inv_open]])
local snd_close = sound_object([[interface\inv_close]])
local snd_item_to_slot = sound_object([[interface\inv_slot]])
local snd_item_to_belt = sound_object([[interface\inv_belt]])
local snd_item_to_ruck = sound_object([[interface\inv_ruck]])
local snd_properties = sound_object([[interface\inv_properties_2]])
local snd_drop_item = sound_object([[interface\inv_drop]])
local snd_attach_addon = sound_object([[interface\inv_attach_addon]])
local snd_detach_addon = sound_object([[interface\inv_detach_addon]])
local snd_item_use = sound_object([[interface\inv_none]])

local mode_bank = "bank"
local mode_test_bank = "test_bank"
local mode_generic_container = "generic_container"
local mode_ammo_container = "ammo_container"
local mode_med_container = "med_container"
local mode_mats_container = "mats_container"
-- possible variants: artifacts, w/a parts (has durability, seems bad)

RVRData = nil
GUI = nil
ActiveStorages = nil

SpawnerEventSource = "rvr_spawner_event_source"

-----------
--- Config Section
-----------

cfg = {
    ui_storage_min_reset_period_ms = 100,
    spawner_durability_set_delay_seconds = 0.1,

    lister_item_width = 348 -- should be the same as list_box width
}

-----------
--- Config Section end
-----------

-----
--- Categories
-----

categories = {
    { id = "c_weapons",     display_name = "st_c_weapons",     kinds = { "w_sniper", "w_rifle", "w_smg", "w_shotgun", "w_pistol", "w_melee", "w_misc", "w_base", "w_explosive" } },
    { id = "c_ammo",        display_name = "st_c_ammo",        kinds = { "w_ammo" } },
    { id = "c_armor",       display_name = "st_c_armor",       kinds = { "o_heavy", "o_sci", "o_medium", "o_light", "o_helmet" } },
    { id = "c_equipment",   display_name = "st_c_equipment",   kinds = { "i_backpack", "i_device" } },
    { id = "c_tech",        display_name = "st_c_tech",        kinds = { "i_tool", "i_repair", "i_part", "i_upgrade", "i_kit" } },
    { id = "c_trophies",    display_name = "st_c_trophies",    kinds = { "i_arty", "i_arty_junk", "i_arty_cont", "i_mutant_raw", "i_mutant_part", "i_mutant_belt" } },
    { id = "c_consumables", display_name = "st_c_consumables", kinds = { "i_food", "i_mutant_cooked", "i_drink", "i_medical" } },
    { id = "c_misc",        display_name = "st_c_misc",        kinds = { "i_letter", "i_quest", "i_misc" } },
    { id = "c_unknown",     display_name = "st_c_unknown",     kinds = { "unknown" } },
}

-----
--- Categories end
-----

function start(mode, storage)
    if (not mode) then
        printdbg("nil mode received")

        return
    end

    if (not GUI) then
        GUI = UIStorage()
    end

    if (GUI) and (not GUI:IsShown()) then
        if mode == mode_bank then
            -- change_last_mode(1)
            GUI:BankMode_Init(storage)
        elseif mode == mode_test_bank then
            GUI:TestBankMode_Init(storage)
        elseif mode == mode_generic_container then
            GUI:GenericCMode_Init(storage)
        elseif mode == mode_ammo_container then
            GUI:AmmoCMode_Init(storage)
        elseif mode == mode_med_container then
            GUI:MedCMode_Init(storage)
        elseif mode == mode_mats_container then
            GUI:MatsCMode_Init(storage)
        else
            printf("unexpected mode")

            return
        end

        GUI:ShowDialog(true)

        _GUIs_keyfree["UIStorage"] = true
        Register_UI("UIStorage", "ui_storage")
    end
end

function init()
    news_manager.send_tip(db.actor, "Reaver Storage System initialized", nil, nil, 30000)
    InitDefaultStorages()
    InitActiveStorages()
end

function actor_item_to_ruck()
    if GUI and GUI:IsShown() then
        GUI:Reset()
    end
end

function on_actor_inventory_update_finished()
    local delay_seconds = 0.1
    -- local expiration_time = time_global() + 3 * delay_seconds * 1000
    -- because fokin server objects have delayed unregistration
    CreateTimeEvent(SpawnerEventSource, "update_storage_gui", delay_seconds, function()
        if GUI and GUI:IsShown() then
            GUI:Reset(true) --force update
        end

        return true -- needed to remove event from queue
    end)
end

function on_storage_inventory_update_finished(storage)
    if GUI and GUI:IsShown() then
        GUI:Reset()
    end
end

-- Function called when a key is pressed
function on_key_press(dik)
    if dik == DIK_keys.DIK_O then
        start(mode_test_bank, ActiveStorages["test_bank"])
    end
end

function save_state(m_data)
    local rvr_storage_system_data = {
        RVRData = RVRData
    }

    m_data.rvr_storage_system_data = rvr_storage_system_data
end

function load_state(m_data)
    if not m_data.rvr_storage_system_data then
        return
    end

    RVRData = m_data.rvr_storage_system_data.RVRData
end

-----------------------------------------------------------------
class "ItemListElement" (CUIListBoxItem)

function ItemListElement:__init(section, width, name, durability, amount, opts)
    local height = 22
    -- local offset = 5
    local opts = opts or {}

    super(section, width)

    self.inactive        = opts.inactive or false

    self.name            = name
    self.section         = section
    self.durability      = ConvertPercentStrToNum(durability)
    self.durability_text = durability
    self.amount          = amount

    self.name_f          = self:GetTextItem()
    self.name_f:SetWndRect(Frect():set(0, 0, width, 22))
    self.name_f:SetWndSize(vector2():set(width - 120, 22))
    self.name_f:SetText(name)

    if not opts.hide_durability then
        self.durability_f = self:AddTextField(durability, 1)
        self.durability_f:SetWndRect(Frect():set(0, 0, 50, 22))
        self.durability_f:SetWndPos(vector2():set(width - 100, 0))
        self.durability_f:SetText(durability)
    end

    if not opts.hide_amount then
        self.amount_f = self:AddTextField(amount, 2)
        self.amount_f:SetWndRect(Frect():set(0, 0, 50, 22))
        self.amount_f:SetWndPos(vector2():set(width - 50, 0))
        self.amount_f:SetText(amount)
    end
end

-----------------------------------------------------------------
class "ItemListSeparator" (CUIListBoxItem)

function ItemListSeparator:__init(index, title, opts)
    local height = 22
    local offset = 5
    local width = cfg.lister_item_width
    local opts = opts or {}
    local line = "_________________________"
    local text_color = opts.text_color or GetARGB(255, 255, 255, 255)

    super(index, width)

    self.inactive = opts.inactive or true

    self.left_f = self:AddTextField(line, 1)
    self.left_f:SetText(line)
    self.left_f:SetTextColor(opts.text_color)
    self.left_f:SetWndRect(Frect():set(0, 0, width, 22))
    self.left_f:SetWndPos(vector2():set(0, 0))

    self.title_f = self:AddTextField(title, 2)
    -- self.title_f:SetEllipsis(true)
    self.title_f:SetText(title)
    self.title_f:SetTextColor(opts.text_color)
    self.title_f:SetWndRect(Frect():set(0, 0, width, 22))
    self.title_f:SetWndPos(vector2():set(width / 2 - 50, 0))

    self.right_f = self:AddTextField(line, 3)
    self.right_f:SetText(line)
    self.right_f:SetTextColor(opts.text_color)
    self.right_f:SetWndRect(Frect():set(0, 0, width, 22))
    self.right_f:SetWndPos(vector2():set(width / 2 + 50, 0))

    -- self.title_f = self:GetTextItem()
    -- self.title_f:SetText(title)
end

-----------------------------------------------------------------
class "UIStorage" (CUIScriptWnd)

function UIStorage:__init()
    super()
    self.mode = mode_test_bank
    self.next_reset_time = 0
    self:InitControls()
    self:InitCallBacks()
end

function UIStorage:__finalize()
end

function UIStorage:InitControls()
    self:SetWndRect(Frect():set(0, 0, 1024, 768))

    self.xml = CScriptXmlInit()
    local xml = self.xml
    xml:ParseFile("ui_rvr_storage.xml")

    self.actor_d       = xml:InitStatic("stg_actor_inventory", self)
    self.actor_d_frame = xml:InitFrame("stg_actor_inventory:frame_base", self.actor_d)
    self.actor_d_list  = xml:InitFrame("stg_actor_inventory:frame_list", self.actor_d)
    self.actor_d_cap   = xml:InitStatic("stg_actor_inventory:cap", self.actor_d)
    self.actor_inv     = xml:InitListBox("stg_actor_inventory:list", self.actor_d_list)
    self:Register(self.actor_inv, "move_actor_item_db_click")

    self.storage_d       = xml:InitStatic("stg_storage_inventory", self)
    self.storage_d_frame = xml:InitFrame("stg_storage_inventory:frame_base", self.storage_d)
    self.storage_d_list  = xml:InitFrame("stg_storage_inventory:frame_list", self.storage_d)
    self.storage_d_cap   = xml:InitStatic("stg_storage_inventory:cap", self.storage_d)
    self.storage_inv     = xml:InitListBox("stg_storage_inventory:list", self.storage_d_list)
    self:Register(self.storage_inv, "move_storage_item_db_click")
end

function UIStorage:InitCallBacks()
    self:AddCallback("move_storage_item_db_click", ui_events.WINDOW_LBUTTON_DB_CLICK, self.OnStorageItemList, self)
    self:AddCallback("move_actor_item_db_click", ui_events.WINDOW_LBUTTON_DB_CLICK, self.OnActorItemList, self)
    -- self:AddCallback("itm_type", ui_events.LIST_ITEM_SELECT, self.OnItemType, self)
    -- self:AddCallback("itm_list", ui_events.LIST_ITEM_SELECT, self.OnItemList, self)
    -- self:AddCallback("button_name", ui_events.BUTTON_CLICKED, self.OnButton_Name, self)
    -- self:AddCallback("check_inv", ui_events.BUTTON_CLICKED, self.OnButton_Inv, self)
    -- self:AddCallback("check_point", ui_events.BUTTON_CLICKED, self.OnButton_Point, self)
    -- self:AddCallback("list", ui_events.WINDOW_LBUTTON_DB_CLICK, self.OnStartAnim, self)
end

-- Test bank mode
function UIStorage:TestBankMode_Init(storage)
    self.mode = mode_test_bank
    self.storage = storage
    self.multiplier = 1
    -- self:PlaySND(snd_open)

    self:LogTr("TestBankMode_Init call")
    self:Log("storage params: id=%s | weight_limit=%s", tostring(storage:GetID()), tostring(storage:GetWeightLimit()))

    self:Reset()
end

function UIStorage:Close()
    self:Log("Close")

    -- Sound effect
    -- self:PlaySND(snd_close)

    self:HideDialog()
    self:Show(false)

    Unregister_UI("UIStorage")
end

function UIStorage:Reset(force)
    if not force and self.next_reset_time > time_global() then
        return
    end

    self.next_reset_time = time_global() + cfg.ui_storage_min_reset_period_ms

    self:LogTr("Reset call")

    local actor_inv_pos = self.actor_inv:GetCurrentScrollPos()
    local storage_inv_pos = self.storage_inv:GetCurrentScrollPos()

    self.storage_inv:Clear()
    self.actor_inv:Clear()

    self:RenderActorInv()
    self:RenderStorageInv()

    CUIScriptWnd.Update(self)
    self:Update()

    self.actor_inv:SetScrollPos(actor_inv_pos)
    self.storage_inv:SetScrollPos(storage_inv_pos)
end

-- Refresh UNIMPLEMENTED update counters without reset.
function UIStorage:Refresh()
    self:Log("Refresh")
    -- todo update counters without reset
end

function UIStorage:RenderStorageInv()
    local lister = Lister():FromStorage(self.storage)
    if not lister then
        self:LogTr("nil lister")

        return
    end

    local elements = lister:GetListElements()

    self:Render(self.storage_inv, elements)
end

function UIStorage:RenderActorInv()
    local inv = GetInventoryListEntries(db.actor)

    local lister = Lister():FromNPCInv(inv)
    if not lister then
        self:LogTr("nil lister")

        return
    end

    local elements = lister:GetListElements()

    self:Render(self.actor_inv, elements)
end

function UIStorage:Render(list_box, elements)
    if not list_box then
        self:LogTr("error: nil list_box")

        return
    end
    if not elements then
        self:LogTr("error: nil elements")

        return
    end

    for _, el in pairs(elements) do
        list_box:AddExistingItem(el)
    end
end

function UIStorage:OnKeyboard(dik, keyboard_action)
    local res = CUIScriptWnd.OnKeyboard(self, dik, keyboard_action)
    if res ~= false then
        return res
    end

    if keyboard_action == ui_events.WINDOW_KEY_PRESSED then
        if dik == DIK_keys.DIK_ESCAPE then
            self:Close()

            return
        end

        if dik == DIK_keys.DIK_LSHIFT then
            self.multiplier = self.multiplier * 5

            return
        end

        if dik == DIK_keys.DIK_LCONTROL then
            self.multiplier = self.multiplier * 5

            return
        end
    end

    if keyboard_action == ui_events.WINDOW_KEY_RELEASED then
        if dik == DIK_keys.DIK_LSHIFT then
            self.multiplier = math.max(self.multiplier / 5, 1)

            return
        end

        if dik == DIK_keys.DIK_LCONTROL then
            self.multiplier = math.max(self.multiplier / 5, 1)

            return
        end
    end

    if keyboard_action == ui_events.WINDOW_LBUTTON_UP then
        self:Reset()
    end

    local bind = dik_to_bind(dik)
    if bind == key_bindings.kINVENTORY or bind == key_bindings.kUSE then
        self:Close()

        return
    end
end

function UIStorage:OnStorageItemList()
    self:Log("OnStorageItemList call")

    local pick = self.storage_inv:GetSelectedItem()
    if not pick or pick.inactive then
        return
    end

    local amount = math.min(CalculatePutOrGetAmount(pick.section, pick.amount) * self.multiplier, pick.amount)

    self.storage:Get(pick.section, pick.durability_text, amount)
    printf("put " .. pick.section .. " " .. pick.durability .. "amount= " .. amount)

    SpawnItem(db.actor, pick.section, amount, pick.durability)

    self:Reset()
end

function UIStorage:OnActorItemList()
    printf("OnActorItemList")

    local pick = self.actor_inv:GetSelectedItem()
    if not pick or pick.inactive then
        return
    end

    local amount = CalculatePutOrGetAmount(pick.section, pick.amount) * self.multiplier
    local absent_amount = RemoveItems(db.actor, pick.section, amount, pick.durability)
    self.storage:Put(pick.section, pick.durability_text, amount - absent_amount)
    printf("put " .. pick.section .. " " .. pick.durability .. "amount= " .. amount)

    self:Reset()
end

function UIStorage:Log(msg, ...)
    if not msg then
        return
    end

    -- mode, weight_limit, storage (id, weight_limit)
    local st_id = "undefined"
    local st_wl = "undefined"
    if self.storage then
        st_id = tostring(self.storage:GetID())
        st_wl = tostring(self.storage:GetWeightLimit())
    end

    local ui_mode = "undefined"
    if self.mode then
        ui_mode = tostring(self.mode)
    end

    local ctx = string.format(
        "[module: %s | mode: %s| st_id: %s | st__wl: %s]",
        "UIStorage",
        ui_mode,
        st_id,
        st_wl
    )

    msg = msg .. " |---| ctx=" .. ctx

    log(msg, ...)
end

function UIStorage:LogTr(msg, ...)
    log(debug.traceback())
    self:Log(msg, ...)
end

----------------------------------------------------------------- Storage

class "Storage"

function Storage:__init(id, weight_limit, content)
    self.ID = id
    self.WeightLimit = weight_limit
    self.Content = content
end

function Storage:__finalize()

end

-- Get returns {section, durability, amount} on success or nil
function Storage:Get(section, durability, amount)
    if self.Content[section] == nil then
        return
    end
    if self.Content[section][durability] == nil then
        return
    end

    amount = math.min(amount, self.Content[section][durability].amount)

    self.Content[section][durability].amount = self.Content[section][durability].amount - amount

    -- todo sort here
    return {
        section = section,
        durability = durability,
        amount = amount
    }
end

function Storage:Put(section, durability, amount)
    -- todo check max weight
    if self.Content[section] == nil then
        self.Content[section] = {}
    end
    if self.Content[section][durability] == nil then
        self.Content[section][durability] = {
            amount = 0
        }
    end


    self.Content[section][durability].amount = self.Content[section][durability].amount + amount

    SendScriptCallback("on_storage_inventory_update_finished", self)
    -- todo sort here
end

function Storage:GetID()
    return self.ID
end

function Storage:GetWeightLimit()
    return self.WeightLimit
end

-- GetContent returns Content field which is a table[section][durability]{amount}
function Storage:GetContent()
    return self.Content
end

-----
--- Lister
-----

class "Lister"

function Lister:__init()
    self.ListElements = {}
end

function Lister:__finalize()

end

function Lister:FromNPCInv(inv)
    if not inv then
        return nil
    end

    for sec, by_sec in pairs(inv) do
        for durability, by_durability in pairs(by_sec) do
            local amount = CalculateItemsAmount(by_durability)

            if amount > 0 then
                local _E = ItemListElement(sec, cfg.lister_item_width, GetObjectName(sec),
                    durability, amount)
                _E:SetTextColor(GetARGB(255, 150, 150, 250))

                table.insert(self.ListElements, _E)
            end
        end
    end

    return self
end

function Lister:FromStorage(storage)
    if not storage or not storage.GetContent then --todo seems here
        return nil
    end

    for sec, by_durability in pairs(storage:GetContent()) do
        for durability, item in pairs(by_durability) do
            if item.amount > 0 then
                local _E = ItemListElement(sec, cfg.lister_item_width, GetObjectName(sec),
                    durability, item.amount)
                _E:SetTextColor(GetARGB(255, 150, 150, 250))

                table.insert(self.ListElements, _E)
            end
        end
    end

    return self
end

-- GetListElements returns ItemListElement table
function Lister:GetListElements(opts)
    return self:Sort(self.ListElements, opts)
end

function Lister:Sort(elements, opts)
    local result = {}
    local by_kind = self:GroupByKind(elements, opts)
    local by_cat_kind = self:GroupByCategory(by_kind, opts)
    local kind_order = {}

    for _, cat in pairs(GetCategoriesOrder()) do
        local bk = by_cat_kind[cat]
        if bk then
            local name = game.translate_string(cat.display_name) or cat.display_name
            table.insert(result, self:MakeCategoryElement(name))

            for _, kind in pairs(GetKindsOrder(bk)) do
                if bk[kind] then
                    local name = game.translate_string("st_" .. kind) or "st_" .. kind
                    table.insert(result, self:MakeKindElement(name))

                    for _, el in pairs(bk[kind]) do
                        table.insert(result, el)
                    end
                end
            end
        end
    end

    return result
end

-- todo maybe "meta" sorting will be required in future
-- GroupByKind returns table[kind]elements. Elements are sorted by name and durability
function Lister:GroupByKind(elements, opts)
    local result = {}

    for _, el in pairs(elements) do
        local sec = el.section
        if not sec then
            log("Lister: undefined section while grouping by kind!")
            goto continue
        end

        local kind = SYS_GetParam(0, sec, "kind") or "unknown"
        result[kind] = result[kind] or {}

        table.insert(result[kind], el)

        ::continue::
    end

    for kind, els in pairs(result) do
        table.sort(result[kind], function(e1, e2)
            if (GetObjectName(e1.section) == GetObjectName(e2.section)) then
                return (e1.durability_text > e2.durability_text)
            end

            return (GetObjectName(e1.section) < GetObjectName(e2.section))
        end)
    end

    return result
end

-- GroupByCategory returns table[category][kind]elements. Expects table[kind]
function Lister:GroupByCategory(grouped_by_kind_elements, opts)
    local cat_by_kind_index = GetCategoriesByKind()
    local result = {}

    for kind, els in pairs(grouped_by_kind_elements) do
        local cat = cat_by_kind_index[kind] or cat_by_kind_index["unknown"]

        result[cat] = result[cat] or {}
        result[cat][kind] = els
    end

    return result
end

function Lister:MakeCategoryElement(title)
    local opts = {
        inactive = true,
        text_color = GetARGB(255, 0, 204, 204)
    }

    local el = ItemListSeparator(title, title, opts)

    return el
end

function Lister:MakeKindElement(title)
    local opts = {
        inactive = true,
        text_color = GetARGB(255, 0, 153, 153)
    }

    local el = ItemListSeparator(title, title, opts)

    return el
end

----------------------------------------------------------------- utils

-- GetInventoryListEntries returns a list of lists, grouped by section -> durability
function GetInventoryListEntries(npc, all)
    local inv = GetInventoryMergedBySection(npc, all)
    local list_entries = {}

    for sec, items in pairs(inv) do
        for _, item in pairs(items) do
            local durability = GetObjectDurability(item)

            if list_entries[sec] == nil then
                list_entries[sec] = {}
            end
            if list_entries[sec][durability] == nil then
                list_entries[sec][durability] = {}
            end

            table.insert(list_entries[sec][durability], item)
        end
    end
    -- todo sort here

    return list_entries
end

function GetInventoryMergedBySection(npc, all)
    local inv = GetInventory(npc, all)
    local merged_inv = {}

    for _, item in pairs(inv) do
        local sec = item:section()

        if merged_inv[sec] == nil then
            merged_inv[sec] = {}
        end

        table.insert(merged_inv[sec], item)
    end

    return merged_inv
end

function GetInventory(npc, all)
    local inv = {}

    local sec, kind

    local function iterate(owner, obj)
        sec = obj:section()
        log("GetInventory: got section: %s", sec)

        table.insert(inv, obj)
    end

    if all then
        npc:iterate_inventory(iterate, nil)
    else
        npc:iterate_ruck(iterate, nil)
    end

    return inv
end

function GetObjectDurability(obj)
    local durability = ""

    if obj then
        if obj.condition == nil then
            printf(obj:section() .. " has no condition() method!")
            return "-1"
        end
        durability = tostring(tonumber(math.floor(obj:condition() * 100))) .. "%"
    end

    return durability
end

-- GetObjectName returns localized object name by section. Parameter - string, section.
function GetObjectName(section)
    local inv_name = ui_item.get_sec_name(section)

    if inv_name ~= "" then
        return inv_name
    end

    return section
end

-- GetObjectAmount return an amount of items. Ex. for ammo it returns an amount of ammo in the box, for consumables - remaining number of uses.
--
-- Type - number
function GetItemAmount(obj)
    if not obj then
        return 1
    end

    local kind = SYS_GetParam(0, obj:section(), "kind") or "na"

    if kind == "w_ammo" then
        return tonumber(obj:ammo_get_count())
    end

    local amount = 1
    if obj:get_remaining_uses() > 0 then
        amount = tonumber(obj:get_remaining_uses())
    end

    return amount
end

function CalculateItemsAmount(objects)
    local amount = 0

    for _, obj in pairs(objects) do
        amount = amount + GetItemAmount(obj)
    end

    return amount
end

function InitDefaultStorages()
    if RVRData == nil then
        RVRData = {}
    end

    if RVRData.Storages == nil then
        RVRData.Storages = {}
    end

    if RVRData.Storages["test_bank"] == nil then
        RVRData.Storages["test_bank"] = {
            id = "test_bank",
            mode = mode_test_bank,
            weight_limit = 0,
            content = {
                ["ammo_7.62x51_ap"] = {
                    ["100%"] = {
                        amount = 1500000
                    }
                },
                ["medkit_army"] = {
                    ["100%"] = {
                        amount = 3000000
                    }
                },
                ["grenade_rgd5"] = {
                    ["100%"] = {
                        amount = 3000000
                    }
                }
            }
        }
    end
end

function MakeStorageFromData(mode, params)
    if mode == mode_test_bank then
        local st = Storage(params.id, params.weight_limit, params.content)

        return st
    end

    printf("unknown storage mode: " .. tostring(mode))
    return
end

function InitActiveStorages()
    for id, storage in pairs(RVRData.Storages) do
        if ActiveStorages == nil then
            ActiveStorages = {}
        end

        ActiveStorages[storage.id] = MakeStorageFromData(storage.mode, {
            id = storage.id,
            weight_limit = storage.weight_limit,
            content = storage.content
        })

        printf("initialized ActiveStorage id=" ..
            tostring(storage.id) .. " val=" .. tostring(ActiveStorages[storage.id]:GetContent()))
    end
end

function CalculatePutOrGetAmount(section, pickAmount)
    local kind = SYS_GetParam(0, section, "kind") or "na"

    if kind == "w_ammo" then
        local num_in_box = ini_sys:r_u32(section, "box_size")

        return math.min(num_in_box, pickAmount)
    end

    local max_uses = IsItem("multiuse", section) or 1

    return math.min(max_uses, pickAmount)
end

function SpawnItem(npc, section, amount, durability)
    amount = amount or 1
    local remaining = 0
    local iterations = amount

    local kind = SYS_GetParam(0, section, "kind") or "na"
    if kind == "w_ammo" then
        local box_size = ini_sys:r_u32(section, "box_size")
        if box_size == 0 then
            log("!! box_size is 0 for " .. section)
            return
        end

        remaining = amount % box_size
        iterations = math.floor((amount - remaining) / box_size)
    else
        local max_uses = IsItem("multiuse", section) or 1

        remaining = amount % max_uses
        iterations = math.floor((amount - remaining) / max_uses)
    end

    if remaining ~= 0 then
        local se_obj = alife_create_item(section, npc, {
            ["cond"] = durability,
            ["uses"] = remaining,
            ["ammo"] = remaining
        })

        if npc:id() == AC_ID then
            SendScriptCallback("on_actor_inventory_update_finished")
        end
    end

    printf("SpawnItem stats(amount, remaining, iterations): " .. amount .. " " .. remaining .. " " .. iterations)

    while iterations > 0 do
        local se_obj = alife_create_item(section, npc, {
            ["cond"] = durability
        })

        iterations = iterations - 1
        if npc:id() == AC_ID then
            SendScriptCallback("on_actor_inventory_update_finished")
        end

        if se_obj then
            CreateTimeEvent(SpawnerEventSource, "zzzzz", cfg.spawner_durability_set_delay_seconds, function()
                local obj = get_object_by_id(se_obj.id)
                printf("id=" .. obj:id())
                printf("durability=" .. durability)
                obj:set_condition(durability + 0.005) -- because sometimes it sets 1% lower, maybe precision issues

                SendScriptCallback("on_actor_inventory_update_finished")

                return true
            end)
        end
    end
end

-- RemoveItems returns remaining amount, that cannot be removed
function RemoveItems(npc, section, amount, durability)
    -- todo dura checks
    amount = amount or 1

    local kind = SYS_GetParam(0, section, "kind") or "na"
    local cnt = amount
    local max_uses = IsItem("multiuse", section)
    local keep_itr = true

    local function itr_item(temp, obj)
        if keep_itr and (obj and obj:section() == section and CheckDurability(obj:condition(), durability)) then
            local uses = max_uses and obj:get_remaining_uses() or 1
            cnt = cnt - uses
            if (cnt >= 0) then
                alife_release_id(obj:id(), "released " .. obj:id())

                if (cnt == 0) then
                    keep_itr = false
                end
            else
                local remain = -cnt
                SpawnItem(npc, section, remain, durability)
                keep_itr = false
            end
        end
    end

    local function itr_ammo(temp, obj)
        if keep_itr and (obj and obj:section() == section) then
            cnt = cnt - obj:ammo_get_count()
            if (cnt >= 0) then
                alife_release_id(obj:id(), "released " .. obj:id())

                if (cnt == 0) then
                    keep_itr = false
                end
            else
                local remain = -cnt
                SpawnItem(npc, section, remain, durability)
                keep_itr = false
            end
        end
    end

    if cnt > 0 then
        log("RemoveItems cannot remove all items! Left: %d", cnt)
    end

    if kind == "w_ammo" then
        npc:iterate_ruck(itr_ammo, nil)
    else
        npc:iterate_ruck(itr_item, nil)
    end

    SendScriptCallback("on_actor_inventory_update_finished")

    return cnt
end

-- ConvertPercentStrToNum converts "78%" to 0.78
function ConvertPercentStrToNum(durStr)
    if type(durStr) == "number" then
        return durStr
    end

    durStr = durStr:gsub("%%$", "")
    local num = tonumber(durStr)
    if num == nil then
        printf("ConvertPercentStrToNum: num is nil")

        return 0
    end

    return num / 100
end

-- CheckDurability compares durabilities. Expected non-percent form of arguments (d1 and d2 < 1)
function CheckDurability(d1, d2)
    if not d1 or not d2 then
        return false
    end

    if type(d1) == "number" and type(d2) == "number" then
        return math.floor(d1 * 100) == math.floor(d2 * 100)
    end

    return false
end

function GetCategoriesByKind()
    local cat_index = {}
    for _, cat in pairs(categories) do
        for _, knd in pairs(cat.kinds) do
            cat_index[knd] = cat
        end
    end

    return cat_index
end

-- GetKindsOrder returns stable kind order from table[kind]
function GetKindsOrder(by_kind)
    local kinds = {}
    for kind, _ in pairs(by_kind) do
        table.insert(kinds, kind)
    end

    table.sort(kinds, function(k1, k2)
        return k1 < k2
    end)


    return kinds
end

function GetCategoriesOrder()
    local order = {}
    for _, cat in pairs(categories) do
        table.insert(order, cat)
    end

    return order
end
