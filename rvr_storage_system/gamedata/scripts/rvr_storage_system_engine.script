function on_game_start()
    RegisterScriptCallback("actor_on_first_update", init)
    RegisterScriptCallback("on_key_press", on_key_press)
    RegisterScriptCallback("save_state", save_state)
    RegisterScriptCallback("load_state", load_state)
end

local weight_unit = game.translate_string("st_kg")
local snd_open = sound_object([[interface\inv_open]])
local snd_close = sound_object([[interface\inv_close]])
local snd_item_to_slot = sound_object([[interface\inv_slot]])
local snd_item_to_belt = sound_object([[interface\inv_belt]])
local snd_item_to_ruck = sound_object([[interface\inv_ruck]])
local snd_properties = sound_object([[interface\inv_properties_2]])
local snd_drop_item = sound_object([[interface\inv_drop]])
local snd_attach_addon = sound_object([[interface\inv_attach_addon]])
local snd_detach_addon = sound_object([[interface\inv_detach_addon]])
local snd_item_use = sound_object([[interface\inv_none]])

local test_storage_calls = 0

local mode_bank = "bank"
local mode_test_bank = "test_bank"
local mode_generic_container = "generic_container"
local mode_ammo_container = "ammo_container"
local mode_med_container = "med_container"
local mode_mats_container = "mats_container"
-- possible variants: artifacts, w/a parts (has durability, seems bad)

GUI = nil

function start(mode, storage)
    if (not mode) then
        printdbg("nil mode received")

        return
    end

    if (not GUI) then
        GUI = UIStorage()
    end

    if (GUI) and (not GUI:IsShown()) then
        if mode == mode_bank then
            -- change_last_mode(1)
            GUI:BankMode_Init(storage)
        elseif mode == mode_test_bank then
            GUI:TestBankMode_Init(storage)
        elseif mode == mode_generic_container then
            GUI:GenericCMode_Init(storage)
        elseif mode == mode_ammo_container then
            GUI:AmmoCMode_Init(storage)
        elseif mode == mode_med_container then
            GUI:MedCMode_Init(storage)
        elseif mode == mode_mats_container then
            GUI:MatsCMode_Init(storage)
        else
            printf("unexpected mode")

            return
        end

        GUI:ShowDialog(true)

        _GUIs_keyfree["UIStorage"] = true
        Register_UI("UIStorage", "ui_storage")
    end
end

function init()
    news_manager.send_tip(db.actor, "Reaver Storage System initialized", nil, nil, 30000)
end

-- Function called when a key is pressed
function on_key_press(dik)
    if dik == DIK_keys.DIK_O then
        -- test_storage_calls = test_storage_calls + 1

        printf("test storage calls: " .. test_storage_calls)
        start(mode_test_bank, nil) -- todo add test object
    end
end

function save_state(m_data) -- todo save stashes
    local rvr_storage_system_data = {
        test_storage_calls = test_storage_calls
    }

    m_data.rvr_storage_system_data = rvr_storage_system_data
end

function load_state(m_data) -- todo load stashes
    if not m_data.rvr_storage_system_data then
        return
    end

    if m_data.rvr_storage_system_data.test_storage_calls and type(m_data.rvr_storage_system_data.test_storage_calls) ==
        "number" then
        test_storage_calls = m_data.rvr_storage_system_data.test_storage_calls
    end
end

-----------------------------------------------------------------
class "ItemListElement" (CUIListBoxItem)

function ItemListElement:__init(index, width, name, durability, amount)
    local height = 22
    local offset = 5

    super(index, width, height, offset, name, nil, obj_related)

    self.index       = index
    self.obj_related = obj_related and true or false

    self.name        = self:GetTextItem()
    self.name:SetText(name)

    self.durability = self:AddTextField(durability, 1)
    self.durability:SetText(durability)
    -- self.durability:SetWndSize(vector2():set((txt_2 and (width - 40) or width), height))
    self.durability:SetWndPos(vector2():set(width - 100, 0))

    self.amount = self:AddTextField(amount, 2)
    self.amount:SetText(amount)
    self.amount:SetWndPos(vector2():set(width - 50, 0))

    -- self.text        = self:GetTextItem()
    -- self.text:SetWndRect(Frect():set(0, 0, width, height))
    -- self:SetTextColor(GetARGB(255, 200, 200, 200))
    -- self.text:SetFont(GetFontLetterica16Russian())
    -- self.text:SetWndSize(vector2():set((txt_2 and (width - 40) or width), height))
    -- self.text:SetWndPos(vector2():set(offset, 0))
    -- self.text:SetEllipsis(true)
    -- self.text:SetText(txt_1)


    -- self.flag = self:AddTextField(str_flag)
    -- self.flag:SetTextColor(GetARGB(255, 170, 170, 250))
    -- self.flag:SetFont(GetFontLetterica16Russian())
    -- self.flag:SetWndSize(vector2():set(40, height))
    -- self.flag:SetWndPos(vector2():set(width - 40, 0))
end

-----------------------------------------------------------------
class "UIStorage" (CUIScriptWnd)

function UIStorage:__init()
    super()
    self.mode = mode_test_bank
    self:InitControls()
end

function UIStorage:__finalize()
end

function UIStorage:InitControls()
    self:SetWndRect(Frect():set(0, 0, 1024, 768))
    -- self:SetAutoDelete(true)

    self.xml = CScriptXmlInit()
    local xml = self.xml
    xml:ParseFile("ui_rvr_storage.xml")

    self.actor_d       = xml:InitStatic("stg_actor_inventory", self)
    self.actor_d_frame = xml:InitFrame("stg_actor_inventory:frame_base", self.actor_d)
    self.actor_d_list  = xml:InitFrame("stg_actor_inventory:frame_list", self.actor_d)
    self.actor_d_cap   = xml:InitStatic("stg_actor_inventory:cap", self.actor_d)
    self.actor_inv     = xml:InitListBox("stg_actor_inventory:list", self.actor_d_list)
    self:Register(self.actor_inv, "actor_inv")

    self.storage_d       = xml:InitStatic("stg_storage_inventory", self)
    self.storage_d_frame = xml:InitFrame("stg_storage_inventory:frame_base", self.storage_d)
    self.storage_d_list  = xml:InitFrame("stg_storage_inventory:frame_list", self.storage_d)
    self.storage_d_cap   = xml:InitStatic("stg_storage_inventory:cap", self.storage_d)
    self.storage_inv     = xml:InitListBox("stg_storage_inventory:list", self.storage_d_list)
    self:Register(self.storage_inv, "storage_inv")
end

-- Test bank mode
function UIStorage:TestBankMode_Init(storage)
    self:Log("TestBankMode_Init")
    self.mode = mode_test_bank
    -- self:PlaySND(snd_open)

    self:Reset()
end

function UIStorage:Close()
    self:Log("Close")

    -- Sound effect
    -- self:PlaySND(snd_close)

    self:HideDialog()
    self:Show(false)

    -- change_last_mode(0)

    Unregister_UI("UIStorage")
end

function UIStorage:Reset(storage)
    self:Log("Reset")
    self:ResetActorInv()
end

function UIStorage:ResetActorInv()
    local inv = GetInventoryListEntries(db.actor)

    for sec, by_sec in pairs(inv) do
        for durability, by_durability in pairs(by_sec) do
            local kind = SYS_GetParam(0, sec, "kind") or "na" -- todo unused

            local _E = ItemListElement(GetObjectName(sec), self.actor_inv:GetWidth(), GetObjectName(sec),
                durability, CalculateItemsAmount(by_durability))

            self.actor_inv:AddExistingItem(_E)

            _E:SetTextColor(GetARGB(255, 150, 150, 250))
        end
    end


    -- for i, item in ipairs(inv) do
    --     printf("---------------------------")
    --     printf(item:id())
    --     printf(item:name()) -- section+id ???
    --     printf(item:section())

    --     local kind = SYS_GetParam(0, item:section(), "kind") or "na"
    --     printf(kind)
    -- end
end

function UIStorage:OnKeyboard(dik, keyboard_action)
    local res = CUIScriptWnd.OnKeyboard(self, dik, keyboard_action)
    if res ~= false then
        return res
    end

    if keyboard_action == ui_events.WINDOW_KEY_PRESSED then
        if dik == DIK_keys.DIK_ESCAPE then
            self:Close()

            return
        end
    end

    local bind = dik_to_bind(dik)
    if bind == key_bindings.kINVENTORY or bind == key_bindings.kUSE then
        self:Close()

        return
    end
end

function UIStorage:Log(msg)
    printf("mode=" .. (self.mode or "undefined"))
    printf(msg)
end

----------------------------------------------------------------- utils

-- GetInventoryListEntries returns a list of lists, grouped by section -> durability
function GetInventoryListEntries(npc, all)
    local inv = GetInventoryMergedBySection(npc, all)
    local list_entries = {}

    for sec, items in pairs(inv) do
        for _, item in pairs(items) do
            if list_entries[sec] == nil then
                list_entries[sec] = {}
            end
            if list_entries[sec][GetObjectDurability(item)] == nil then
                list_entries[sec][GetObjectDurability(item)] = {}
            end

            table.insert(list_entries[sec][GetObjectDurability(item)], item)
        end
    end

    return list_entries
end

function GetInventoryMergedBySection(npc, all)
    local inv = GetInventory(npc, all)
    local merged_inv = {}

    for _, item in pairs(inv) do
        local sec = item:section()

        if merged_inv[sec] == nil then
            merged_inv[sec] = {}
        end

        table.insert(merged_inv[sec], item)
    end

    return merged_inv
end

function GetInventory(npc, all)
    local inv = {}

    local sec, kind

    local function iterate(owner, obj)
        sec = obj:section()
        -- kind = SYS_GetParam(0, sec, "kind") or "na"

        table.insert(inv, obj)
    end

    if all then
        npc:iterate_inventory(iterate, nil)
    else
        npc:iterate_ruck(iterate, nil)
    end

    return inv
end

function GetObjectDurability(obj)
    local durability = ""

    if obj then
        if obj.condition == nil then
            printf(obj:section() .. " has no condition() method!")
            return "-1"
        end
        durability = tostring(tonumber(math.floor(obj:condition() * 100))) .. "%"
    end

    return durability
end

-- GetObjectName returns localized object name by section. Parameter - string, section.
function GetObjectName(section)
    local inv_name = ui_item.get_sec_name(section)

    if inv_name ~= "" then
        return inv_name
    end

    return section
end

-- GetObjectAmount return an amount of items. Ex. for ammo it returns an amount of ammo in the box, for consumables - remaining number of uses.
--
-- Type - number
function GetItemAmount(obj)
    if not obj then
        return 1
    end

    local kind = SYS_GetParam(0, obj:section(), "kind") or "na"

    if kind == "w_ammo" then
        return tonumber(obj:ammo_get_count())
    end

    local amount = 1
    if obj:get_remaining_uses() > 0 then
        amount = tonumber(obj:get_remaining_uses())
    end

    return amount
end

function CalculateItemsAmount(objects)
    local amount = 0

    for _, obj in pairs(objects) do
        amount = amount + GetItemAmount(obj)
    end

    return amount
end
