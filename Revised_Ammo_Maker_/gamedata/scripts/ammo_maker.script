--[[
	@ Name: (Revised) Ammo Maker
	@ Author: Arti, Singustromo
	@ Upstream: https://github.com/ahuyn/anomaly-compilation/tree/master/ammo%20maker

	Functions for external use:
	  get_ammo_recipe(section)
	  breakdown(ammo, tool, batch)
	  is_component(obj)
	  is_component_by_section(sec)
	  component_aggregation(obj, npc)	-- fixed ammo aggregation (lite)
	  adjust_box_by_id(id, count)		
	  aggregate_components_by_id(id)
	  create_components(tbl)		-- spawns in db.actor inventory
--]]

VERSION=1.0

recipe_injector = ammo_maker_recipe_inject -- also used by mcm script

local ammo_recipe_ini
local ammo_settings_ini
local option = {}

function log(message, ...)
	if (option.debug) then printf("[ammo maker] " .. message, ...) end
end

local function float_display(number)
	return string.format("%.2f", number)
end

----------------------------
--	Settings
----------------------------

function load_settings()
	local settings = ammo_maker_mcm

	option.salvage_preset = settings.get_value("salvage_preset")
	option.tool_degradation = settings.get_value("tool_degradation")
	option.powder_bonus = settings.get_value("powder_bonus")
	option.rate_bad = settings.get_value("rate_bad")
	option.debug = settings.get_value("debug")
	option.show_news = settings.get_value("show_news")
	option.force_injection = recipe_injector and settings.get_value("force_injection")
	option.inject_bad = settings and settings.get_value("inject_bad_variants")
end

----------------------------
--	Dependencies
----------------------------

local randomizer = libmath_bezier
local function random_amount(lower, upper, preset)
	local preset_list = {
		low = {0,1,0,1}, -- ~50%
		normal = {0,1,0.5,1}, -- ~65%
		high = {0,1,1,1}, -- ~75%
	}

	if type(preset) ~= 'table' then 
		preset = preset_list[preset] or preset_list.normal
		if type(preset) ~= 'table' then return end
	end

	local result = randomizer.get_random_value(lower, upper, preset)
	log("randomizer | [%s:%s] -> %s", lower, upper, float_display(result))

	return result
end

----------------------------
--	Main
----------------------------

-- Only applies fraction between 0 and 1 as factor
-- factor is applied when chance is nil or not a fraction
local function apply_factor(amount, limit, factor, chance)
	if not factor or factor <= 0 or factor == 1 then return amount end
	if chance and (type(chance) ~= 'number' or chance <= 0) then return amount end
	
	local product = factor * amount
	local apply_limit = (factor > 1 and product > limit)
		or (factor <= 1 and product <= limit)
	local new_amount = (apply_limit) and limit or product

	if (chance and math.random(0,100) > chance*100) then
		return amount
	end
	log("apply factor | %s * %s -> %s", float_display(amount), factor, float_display(new_amount))
	return new_amount
end

-- slightly modified from workshop_autoinject
local function valid_recipe(craft_string)
	local t = str_explode(craft_string,",")
	
	if not (#t >= 6 and #t <= 10 and #t%2 == 0) then
		log("Not enough components in recipe!")
		return
	end

	local tool = tonumber(t[1])
	if tool < 0 or tool > 5 then
		log("Invalid tool %s! Must be 0-5", tool)
		return
        end

        if not string.find(t[2], "recipe") then
		log("Invalid recipe %s!", t[2])
		return
        end

        for i=3,#t,2 do -- skipping tool, rsp
		local item = t[i]
		local count = tonumber(t[i+1])
		if not ini_sys:section_exist(item) then
			log("Invalid component %s!", item)
			return
		end
		if not count or count <= 0 then
			log("Invalid amount for component %s!", count)
			return
		end
	end
        return true
end

-- returns: table { tool, rsp, component = amount, component = ... }
function get_ammo_recipe(section)
	if (not section or is_component_by_section(section)) then return end
	
	-- we use the same recipe for old ammo and half the yield later on
	if not option.inject_bad and string.find(section, "_bad") then
		section = section:gsub("_bad", "")
	end

	local recipe = not option.force_injection
		and itms_manager.ini_craft:r_string_ex(6, "x_" .. section)
	local need_validation = true
	
	-- Keeping this for compatibility
	if recipe_injector and (not recipe or string.find(recipe, "prt_i_ammo")) then
		log("Trying fallback recipe for %s", section)
		local legacy_recipe = ammo_recipe_ini:r_value("ammo_vanilla", section)
			or ammo_recipe_ini:r_value("ammo_bas", section)

		if legacy_recipe then
			recipe = legacy_recipe
			need_validation = false
		end
	end
	
	if recipe == "" or not recipe then
		printe("! ammo maker | No crafting recipe found for '%s'", section)
	--	callstack(true)
		return
	end

	if need_validation and not valid_recipe(recipe) then
		printe("! ammo maker | Invalid crafting recipe for '%s'", section)
		return
	end
	
	return str_explode(recipe, ",")
end

-- Breaksdown the ammunition boxes
-- Returns: table (Parts, their quantity and the overall ammo count)
function do_breakdown(ammo_list, tool_condition, preset)
	local tbl = {}
	if is_empty(ammo_list) or not tool_condition then return end

	local sec = ammo_list[1]:section()
	local ammo_name = ui_item.get_sec_name(sec)
	local parts_map = get_ammo_recipe(sec)

	if (is_empty(parts_map)) then return end

	-- salvage settings
	local salvage_rate = ammo_settings_ini:r_float_ex(sec, "salvage_rate") or 1
	local degradation_rate = ammo_settings_ini:r_float_ex(sec, "degradation") or 0.003

	local tool_degrade_sum = 0

	if string.find(sec, "_bad") then
		salvage_rate = salvage_rate * option.rate_bad
	end
	
	for _,box in pairs(ammo_list) do
		-- short circuit, if tool gets depleted
		if tool_degrade_sum > tool_condition then break	end

		local ammo_count = box:ammo_get_count()
		local ammo_box_size = box:ammo_box_size()
		
		for i=3,#parts_map,2 do -- i=3: skipping <tool, recipe> values
			local part_to_make = parts_map[i]
			local part_modifier = tonumber(parts_map[i+1])
			local part_box_size = SYS_GetParam(2, part_to_make, "box_size", 15)
			
			local count = { min = 0, max = part_modifier * part_box_size, final = 0 }
			
			count.max = (ammo_count < ammo_box_size)
				and ammo_count * (count.max / ammo_box_size)
				or count.max
			
			count.final = random_amount(math.floor(count.min), round(count.max), part_to_make, preset)
			
			count.final = apply_factor(count.final, count.max,
				string.find(part_to_make, "powder") and option.powder_bonus or 1)

			count.final = apply_factor(count.final, salvage_rate < 1 and count.min or count.max, salvage_rate)

			count.final = round(count.final)
			if (count.final >= 1) then
				if tbl[part_to_make] then 
					tbl[part_to_make] = tbl[part_to_make] + count.final
				else
					tbl[part_to_make] = count.final
				end
			end
		end

		tbl['ammo_count'] = (tbl['ammo_count'] == nil)
			and ammo_count or tbl['ammo_count'] + ammo_count

		tool_degrade_sum = tool_degrade_sum + option.tool_degradation * degradation_rate
		alife_release_id(box:id())
	end

	return tbl, tool_degrade_sum
end

function degrade_tool(tool, amount)
	if not (tool and amount) then return end
	local name = ui_item.get_sec_name(tool:section())
	local condition = tool:condition()

	tool_degradation = (amount > condition) and condition or amount

	log("degrade | %s (%s) by %s", name, float_display(condition), amount)
	utils_item.degrade(tool, amount)
end

function breakdown(ammo, tool, batch)
	local sec = ammo and ammo:section() or nil
	local name = ui_item.get_sec_name(sec)
	local delay = actor_effects.is_animations_on() and 1 or 0.3 -- seconds
	local tool_condition = tool and tool:condition() or nil

	if (not sec or not tool_condition) then return end

	local to_breakdown = {}
	if (batch) then
		db.actor:iterate_ruck(function(temp, item)
			if (item:section() == sec) then
				table.insert(to_breakdown, item)
			end
		end)
	else
		to_breakdown[1] = ammo
	end
	
	-- Dynamic salvage rate adjustment
	if option.salvage_preset == "dynamic" then
		local rates_eco = { "high", "normal", "low" }
		preset = rates_eco[game_difficulties.get_eco_factor("type")]
		log("preset | Determined by Progression Difficulty: %s", string.upper(preset))
	end

	local tbl, tool_degradation
	tbl, tool_degradation = do_breakdown(to_breakdown, tool_condition, preset)
	if is_empty(tbl) then return end

	degrade_tool(tool, tool_degradation)

	local ammo_count = tbl['ammo_count']
	tbl['ammo_count'] = nil
	
	game_statistics.increment_statistic("items_disassembled")
	actor_effects.play_item_fx("disassemble_metal_fast") -- Animation

	if create_components(tbl) then
		show_salvage_news(tbl, name, ammo_count)
	end
end

----------------------------
--  Bypass Base Functions
----------------------------

function is_component(obj)
	local sec = obj:section()
	if not ini_sys:section_exist(sec) then return end 
	return SYS_GetParam(1, sec, "is_component", false)
end

function is_component_by_section(sec)
	if not ini_sys:section_exist(sec) then return end 
	return SYS_GetParam(1, sec, "is_component", false)
end

-- Fixed (lite) version of the item_weapon.ammo_aggregation()
-- only works with online objects (in current level)
-- TODO: Overhaul to modify less objects overall
function component_aggregation(obj, npc)
	if (not is_component(obj)) then return end

	if (not npc) then
		npc = db.actor
	end
	
	local is_box = IsInvbox(npc)
	local section = obj:section()
	local size = obj:ammo_get_count()
	local box_size = obj:ammo_box_size()
	
	if (size == box_size) then
		return true
	end

	local ammos = {}
	
	-- collect ammos except obj; we use it for remainder
	function collect(temp, item)
		if (section == item:section() and item:id() ~= obj:id() and item:ammo_get_count() < box_size) then
			ammos[#ammos+1] = item:id()
			size = size + item:ammo_get_count()
		end
	end

	if (is_box) then
		npc:iterate_inventory_box(collect)
	else
		npc:iterate_inventory(collect)
	end
	
	-- didn't find any others
	if (size == obj:ammo_get_count()) then return true end
	
	local remainder = size % box_size
	local full_stacks_qty = math.floor(size / box_size)

	log("aggregation | %s | size: %s | stacks_qty: %s; remainder: %s",
		section, size, full_stacks_qty, remainder)

	if (remainder > 0) then 
		obj:ammo_set_count(remainder)
	else 
		ammos[#ammos+1] = obj:id()
	end
	
	for i=1,#ammos do 
		local item = get_object_by_id(ammos[i])
		if (not item) then goto continue end

		if (full_stacks_qty > 0) then
			item:ammo_set_count(box_size)
			full_stacks_qty = full_stacks_qty - 1
		else
			if not is_box then
				npc:drop_item(item)
			end
			alife_release_id(ammos[i])
		end
		::continue::
	end
	
	return true
end

-- changes box_size of an ammo object by id
function adjust_box_by_id(id, count)
	local box = get_object_by_id(id)
	if not IsAmmo(box) then return true end

	if (box) then
		box:ammo_set_count(count)
		return true 
	end
end

-- combines stacks in actor inventory of the same type as id
function aggregate_components_by_id(id)
	local box = get_object_by_id(id)
	if (box) then
		component_aggregation(box)
		return true
	end
end

-- Spawns components tbl{sec, amount, ...} in players inventory
-- Circumvent get_object_by_id() errors caused by alife():create_ammo(..)
-- TODO: add checks from itms_manager: ItemProcessor:Create_Item
function create_components(tbl)
	if not type(tbl) == 'table' then return end
	local ids_to_aggregate = {}

	for part, amount in pairs(tbl) do
		if not is_component_by_section(part) then
			log("! create | %s not a component, skipping", part)
			goto continue
		end

		local part_box_size = SYS_GetParam(2, part, "box_size", 15)
		if amount >= part_box_size then
			log("create | %s | %s stacks (%s each)", part,
				math.floor(amount/part_box_size), part_box_size)
		end

		while (amount >= part_box_size) do -- Spawning whole stacks
			alife_create(part, db.actor:position(),
				db.actor:level_vertex_id(),
				db.actor:game_vertex_id(), AC_ID)

			amount = amount - part_box_size
		end
		if (amount < 1) then goto continue end

		log("create | %s | %s pieces", part, amount)
		local se_obj = alife_create(part, db.actor:position(),
			db.actor:level_vertex_id(), db.actor:game_vertex_id(), AC_ID)
		if (not se_obj) then return end

		CreateTimeEvent("ammo_maker", "set_box_size_"..se_obj.id, 0,
			adjust_box_by_id, se_obj.id, amount)
		
		if IsAmmo(se_obj) then
			ids_to_aggregate[#ids_to_aggregate +1] = se_obj.id
		end

		::continue::
	end
	
	for _, id in pairs(ids_to_aggregate) do
		CreateTimeEvent(ammo_maker, "component_aggregation_" .. id, 0.1,
			aggregate_components_by_id, id)
	end

	return true
end

----------------------------
--	User Interface
----------------------------

local function create_disassemble_list(t)
	local str = ""
	for k,v in pairs(t) do
		str = str .. "\\n- " .. v .. " " .. ui_item.get_sec_name(k)
	end
	return str
end

function show_salvage_news(tbl, name, ammo_count)
	if not option.show_news then return end

	local parts_list = create_disassemble_list(tbl)
	local msg = ""
	local type= "success"

	local title = (ammo_count) and (ammo_count .. "x " .. name) or name

	if (not parts_list or parts_list == "") then
		msg = "\\n" .. game.translate_string("st_dis_text_no_result")
		type = "fail"
	else
		msg = msg .. game.translate_string("st_dis_text_9")
	end
	
	actor_menu.set_item_news(type, "weapon_ammo", "st_dis_text_11", title, msg, parts_list)
end

function _is_suitable_dtool(obj, obj_d)
	if item_parts.is_suitable_dtool(obj, obj_d) then return true end

	if IsWeapon(obj) then
		actor_menu.set_item_news('fail', 'weapon', "st_dis_text_3", " ")
	else
		news_manager.send_tip(db.actor, game.translate_string("st_news_dis_items"), nil, "swiss_knife", 6000)
	end
end

function wrap_disassemble(obj, obj_d, batch)
	obj_d = obj_d or item_parts.get_suitable_dtool(obj)
	if not _is_suitable_dtool(obj, obj_d) then return end

	if IsAmmo(obj) then
		breakdown(obj, obj_d, batch)
	else
		item_parts.disassembly_item(obj, obj_d)
	end
end

Disassemble = item_parts.disassembly_item
function item_parts.disassembly_item(obj, obj_d) -- Monkey patching
	obj_d = obj_d or item_parts.get_suitable_dtool(obj)
	if not _is_suitable_dtool(obj, obj_d) then return end

	if IsAmmo(obj) then
		breakdown(obj, obj_d, false)
	else
		Disassemble(obj, obj_d)
	end
end

function check_batch(obj)
	if is_component(obj) then return end
	return 'st_batch_breakdown'
end

NameCustom = ui_inventory.UIInventory.Name_Custom
function ui_inventory.UIInventory:Name_Custom(obj, bag, temp, i)
	obj = self:CheckItem(obj,"Name_Custom " .. i)
	if i == 4 and IsAmmo(obj) then
		return check_batch(obj)
	else
		return NameCustom(self, obj, bag, temp, i)
	end
end

ActionCustom = ui_inventory.UIInventory.Action_Custom
function ui_inventory.UIInventory:Action_Custom(obj, bag, temp, i)
	obj = self:CheckItem(obj,"Action_Custom " .. i)
	if i == 4 and IsAmmo(obj) then
		wrap_disassemble(obj, nil, true)
	else
		ActionCustom(self, obj, bag, temp, i)
	end
end

----------------------------
--	Initialization
----------------------------

function on_game_start()
	RegisterScriptCallback("on_option_change", load_settings)
	RegisterScriptCallback("on_game_load", load_settings)
	
	ammo_recipe_ini	= ini_file_ex("items\\ammo\\importer.ltx")
	ammo_settings_ini = ini_file_ex("plugins\\ammo_maker\\importer.ltx")
end
